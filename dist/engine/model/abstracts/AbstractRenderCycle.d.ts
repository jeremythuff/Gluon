import { RenderCycle } from "../interface/RenderCycle";
import { PhaseCB } from "../interface/PhaseCB";
import { RenderPhase } from "../../enum/RenderPhase";
import { Observable } from "@reactivex/rxjs/dist/cjs/Rx";
export declare abstract class AbstractRenderCycle implements RenderCycle {
    protected phase: RenderPhase;
    protected initCBs: PhaseCB[];
    protected loadCBs: PhaseCB[];
    protected updateCBs: PhaseCB[];
    protected renderCBs: PhaseCB[];
    protected pauseCBs: PhaseCB[];
    protected unPauseCBs: PhaseCB[];
    protected unloadCBs: PhaseCB[];
    protected destroyCBs: PhaseCB[];
    constructor();
    protected abstract _runInit(): Observable<{}[]>;
    runInit(): Observable<{}[]>;
    init(): void;
    registerInitAction(initCB: PhaseCB): void;
    protected abstract _runLoad(): Observable<{}[]>;
    runLoad(): Observable<{}[]>;
    load(): void;
    registerLoadAction(cb: PhaseCB): void;
    protected abstract _runUpdate(delta: number): void;
    runUpdate(delta: number): void;
    update(delta: number): void;
    registerUpdateAction(cb: PhaseCB): void;
    protected abstract _runRender(delta: number): void;
    runRender(delta: number): void;
    render(delta: number): void;
    registerRenderAction(cb: PhaseCB): void;
    protected abstract _runPause(): void;
    runPause(): void;
    pause(): void;
    registerPauseAction(cb: PhaseCB): void;
    protected abstract _runUnPause(): void;
    runUnPause(): void;
    unpause(): void;
    registerUnpauseAction(cb: PhaseCB): void;
    protected abstract _runUnLoad(): Observable<{}[]>;
    runUnload(): Observable<{}[]>;
    unload(): void;
    registerUnloadAction(cb: PhaseCB): void;
    protected abstract _runDestroy(): Observable<{}[]>;
    runDestroy(): Observable<{}[]>;
    destroy(): void;
    registerDestroyAction(cb: PhaseCB): void;
    phaseIs(phase: RenderPhase): boolean;
    getPhase(): RenderPhase;
    setPhase(phase: RenderPhase): void;
    private runPhaseCBs(cbs);
}
