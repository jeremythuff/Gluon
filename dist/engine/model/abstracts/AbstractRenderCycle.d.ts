import { RenderCycle } from "../interface/RenderCycle";
import { PhaseCB } from "../interface/PhaseCB";
import { RenderPhase } from "../../enum/RenderPhase";
import { Observable } from "@reactivex/rxjs/dist/cjs/Rx";
export declare abstract class AbstractRenderCycle implements RenderCycle {
    protected phase: RenderPhase;
    protected initCBs: PhaseCB[];
    protected loadCBs: PhaseCB[];
    protected updateCBs: PhaseCB[];
    protected renderCBs: PhaseCB[];
    protected pauseCBs: PhaseCB[];
    protected unPauseCBs: PhaseCB[];
    protected unloadCBs: PhaseCB[];
    protected destroyCBs: PhaseCB[];
    constructor();
    protected abstract _runInit(): Observable<{}[]>;
    runInit(): Observable<{}[]>;
    init(initCB: PhaseCB): void;
    protected abstract _runLoad(): Observable<{}[]>;
    runLoad(): Observable<{}[]>;
    load(cb: PhaseCB): void;
    protected abstract _RunUpdate(delta: number): void;
    runUpdate(delta: number): void;
    update(cb: PhaseCB): void;
    protected abstract _RunRender(delta: number): void;
    runRender(delta: number): void;
    render(cb: PhaseCB): void;
    protected abstract _RunPause(): void;
    runPause(): void;
    pause(cb: PhaseCB): void;
    protected abstract _RunUnPause(): void;
    runUnPause(): void;
    unPause(cb: PhaseCB): void;
    protected abstract _runUnLoad(): Observable<{}[]>;
    runUnload(): Observable<{}[]>;
    unload(cb: PhaseCB): void;
    protected abstract _runDestroy(): Observable<{}[]>;
    runDestroy(): Observable<{}[]>;
    destroy(cb: PhaseCB): void;
    phaseIs(phase: RenderPhase): boolean;
    getPhase(): RenderPhase;
    setPhase(phase: RenderPhase): void;
    private runPhaseCBs(cbs);
}
